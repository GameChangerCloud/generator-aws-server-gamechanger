<% fields.map(field => { _%>
    <% const s = field.relationType_%>
    <% let sqltype = getSQLTableName(field.type) _%>
    <% let entityInfo = field.name + field.type + field.relationType _%>
        <% if (!isScalar(field.type)) { 
            containsRelations = false _%>
            <%  switch (s) {
                case "oneToMany": _%>
                let addedElements<%- entityInfo %> = utils.getAddedElements([], args.<%- field.name%>)
                        for (let index = 0; index < addedElements<%- entityInfo %>.length; index++) {
                            sqlRequests.push("UPDATE \"<%- sqltype %>\" SET  \"<%-field.delegated_field.associatedWith.fieldName%>\" = currval(pg_get_serial_sequence('<%- currentType.sqlTypeName %>','Pk_<%- currentType.sqlTypeName %>_id')) WHERE \"Pk_<%- sqltype %>_id\" = " + addedElements<%- entityInfo %>[index])
                        }
                   <% break; 
                case "oneToOne": _%>
                //OneToOne relation
                sqlRequests.push("UPDATE \"<%- field.type.toLowerCase() %>\" SET  \"<%-field.oneToOneInfo.fkName%>\" = 'null'" )

                    <% break; 
                case "oneOnly": _%>
                    <%break
                case "manyToOne":
                    if(!field.joinTable.state){%>
                        //manyToOne
                        let addedElements<%- entityInfo %> = utils.getAddedElements([], args.<%- field.name%>)
                        for (let index = 0; index < addedElements<%- entityInfo %>.length; index++) {
                            sqlRequests.push("UPDATE \"<%- sqltype %>\" SET  \"<%-field.delegated_field.associatedWith.fieldName%>\" = currval(pg_get_serial_sequence('<%- currentType.sqlTypeName %>','Pk_<%- currentType.sqlTypeName %>_id')) WHERE \"Pk_<%- sqltype %>_id\" = " + addedElements<%- entityInfo %>[index])
                        }
                    
                    <%}%>
                   <% break 
                case "manyOnly":_%>
                    //manyOnly
                   					
                    sqlRequests.push("UPDATE \"<%- sqltype %>\" SET  \"<%-field.delegated_field.associatedWith.fieldName%>\" = 'null' WHERE \"<%-field.delegated_field.associatedWith.fieldName%>\" = " +id)
                    <%break
                case "manyToMany": _%>

                    <%break%>
                    <% if (field.noNull) { _%>
    // Case bidirectional, not supported
    // Got the field
                    <% } else { _%>
    // Don't have the field
    // Remove te previous child
    sqlRequests.push("UPDATE \"<%- sqltype %>\" SET \"Fk_<%- currentType.sqlTypeName %>_id\" = null WHERE \"Pk_<%- sqltype %>_id\" = (SELECT \"Pk_<%- sqltype %>_id\" FROM \"<%- sqltype %>\" WHERE \"Fk_<%- currentType.sqlTypeName %>_id\" = " + args.id + ")" )
    sqlRequests.push("UPDATE \"<%- sqltype %>\" SET \"Fk_<%- currentType.sqlTypeName %>_id\" = " + args.id + " WHERE \"Pk_<%- sqltype %>_id\" = " + args.<%- field.name %> )
    utils.startSqlTransaction(sqlRequests, beginParams, commitParams, sqlParams, rdsDataService)
    <% } _%>
                    <% break
                default: _%>
                    <% console.log("Error in handling relationship in create") %>
                    <% break %>
            <% }
        }
})%>
    
