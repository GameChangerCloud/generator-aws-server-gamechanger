sqlRequests = []
sqlRequests.push("INSERT INTO \"<%-sqltypeName%>\" (<%-fieldsName%>) VALUES (" + <%-fieldsCreate%> + ") ")
<% let containsRelations = true %>
<% fields.map(field => { _%>
    <% const s = include('./getRelationBetween',{typeOne: field.type, typeTwo: typeName,relations: relations}) _%>
    <% let sqltype = getSQLTableName(field.type) _%>
        <% if (!isScalar(field.type)) { 
            containsRelations = false _%>
            <%  switch (s.trim()) {  
                case "oneToMany": _%>
                   <% break; 
                case "oneOnly": _%>
                    <%break
                case "manyToOne":%>
                   <% break 
                case "manyOnly":_%>
                    let addedElements<%- sqltype %> = utils.getAddedElements([], args.<%- field.name%>)
                        for (let index = 0; index < addedElements<%- sqltype %>.length; index++) {					
                            sqlRequests.push("UPDATE \"<%- sqltype %>\" SET  \"Fk_<%- sqltypeName %>_id\" = " + args.id + " WHERE \"Pk_<%- sqltype %>_id\" = " + addedElements<%- sqltype %>[index])
                        }
                        utils.startSqlTransaction(sqlRequests, beginParams, commitParams, sqlParams, rdsDataService)
                    <%break
                case "manyToMany": _%>
                    // Get the junction table
                    <% let manyToManyTable = getSQLTableName(JSON.parse(include('getManyToManyTableBetween',{typeOne: typeName,typeTwo: field.type,manyToManyTables: manyToManyTables})).sqlname) %>
    
    // Field <%- field.name %> of type <%- sqltype %>
    for( element in args.<%-field.name%>){
        sqlRequests.push("INSERT INTO \"<%- manyToManyTable %>\" (\"<%- sqltypeName %>_id\", \"<%- sqltype %>_id\") VALUES (currval(pg_get_serial_sequence('<%- sqltypeName %>','Pk_<%- sqltypeName %>_id')), "+ args.<%- field.name%>[element]+")" )
    }
    utils.startSqlTransaction(sqlRequests, beginParams, commitParams, sqlParams, rdsDataService)
    
    
    
                    <%break
                case "oneToOneParent": _%>
                    // A child cannot change its parent in unidirectional
                    if(args.<%- field.name %>) {
        throw 'Error, a child in 1 - 1 unildirectional relation cannot modify its parent' 
    }
                    <# /* Case bidirectional not supported */ %>
                    <% break
                case "oneToOneChild": _%>
                    <% if (field.noNull) { _%>
    // Case bidirectional, not supported
    // Got the field
                    <% } else { _%>
    // Don't have the field
    // Remove te previous child
    sqlRequests.push("UPDATE \"<%- sqltype %>\" SET \"Fk_<%- sqltypeName %>_id\" = null WHERE \"Pk_<%- sqltype %>_id\" = (SELECT \"Pk_<%- sqltype %>_id\" FROM \"<%- sqltype %>\" WHERE \"Fk_<%- sqltypeName %>_id\" = " + args.id + ")" )
    sqlRequests.push("UPDATE \"<%- sqltype %>\" SET \"Fk_<%- sqltypeName %>_id\" = " + args.id + " WHERE \"Pk_<%- sqltype %>_id\" = " + args.<%- field.name %> )
    utils.startSqlTransaction(sqlRequests, beginParams, commitParams, sqlParams, rdsDataService)
    <% } _%>
                    <% break
                default: _%>
                    <% console.log("Error in handling relationship in create") %>
                    <% break %>
            <% }
        }
})%>
    <% if( containsRelations){_%>
        utils.startSqlTransaction(sqlRequests, beginParams, commitParams, sqlParams, rdsDataService)
    <%}%>
